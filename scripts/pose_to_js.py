import pickle
from haptic_control.srv import *
import rospy
from sklearn.metrics import mean_squared_error
import pandas as pd
import math
import numpy as np
from ur5_control.srv import CollCheck

# class for converting a task space plan to a smooth joint space path using
# analysis of inverse kinematic solutions and joint space.
class PoseConversion():
	def __init__(self, file_path, goal = False):
		# load task space trajectory from file
		with open(file_path, 'rb') as f:
			self.pose_trajectory = pickle.load(f)
		# by default, we do not want to downsample the trajectory
		self.down_sample = 1
		
		# if we are given a goal, we have been given a trajectory generated by the LfD model
		# that only has end-effectory position
		# we thus call a function to convert this to a pose by defining the end-effector to 
		# point directly at the goal
		if goal:
			self.update_pose(goal)
			self.down_sample = 3
		
		# define services
		self.calculate_ur5_ik = rospy.ServiceProxy('calculate_ur5_ik', ur5_ik)
		self.calculate_ur5_fk = rospy.ServiceProxy('calculate_ur5_fk', ur5_fk)
		# collision object service-
		self._collision_check = rospy.ServiceProxy('/ur5_control/scene/collision/check', CollCheck)
		
		# define js trajectory list: 
		self.js_trajectory = []

	# called to initiate conversion from the taskspace path to joint space path
	def convert_pose(self):
		# iterate through each pose in the ts trajectory
		js_solutions = []
		js_config = []
		for i in range(0, len(self.pose_trajectory), self.down_sample):
			pose = self.pose_trajectory[i]
			
			# call ur5 ik service, providing it with the desired pose of the ur5
			response = self.calculate_ur5_ik(pose)
			ik_sols = [response.Sol1, response.Sol2, response.Sol3, response.Sol4, response.Sol5, response.Sol6, response.Sol7, response.Sol8]
   			
   			# append solutions to list
			js_solutions.append(ik_sols)

			# calculate the joint configuration numbers of each solution
			config_numbers = []
			js_solution = []
			for js in ik_sols:
				if js:
					config = self.calc_config_number(js)
					config_numbers.append(config)
			# append to list
			js_config.append(config_numbers)

		# implement configuration matching/switching algorithm
		self.config_method(js_solutions, js_config)

	# converts position path to pose path by define ee to point towards goal
	def update_pose(self, goal):
		new_pose_traj = []
		prev_pose = []
		for i in range(len(self.pose_trajectory)):
		# for pose in self.pose_trajectory:
			pose = self.pose_trajectory[i]
			# print(pose)
			v1 = np.array([0, 0, np.linalg.norm(np.subtract(goal, pose))])
			v2 = np.array(np.subtract(goal, pose))
			
			rotation_matrix = self.rotation_matrix_from_vectors(v1, v2)
			rotation_matrix = np.dot(np.array([[-1, 0, 0], [0, -1, 0], [0, 0, 1]]), rotation_matrix)
			new_pose = [rotation_matrix[0][0], rotation_matrix[0][1], rotation_matrix[0][2], -pose[0], rotation_matrix[1][0], rotation_matrix[1][1], rotation_matrix[1][2], -pose[1], rotation_matrix[2][0], rotation_matrix[2][1], rotation_matrix[2][2], pose[2]]
			new_pose_traj.append(new_pose)
			prev_pose = pose
		self.pose_trajectory = new_pose_traj

	def rotation_matrix_from_vectors(self, vec1, vec2):
	    a, b = (vec1 / np.linalg.norm(vec1)).reshape(3), (vec2 / np.linalg.norm(vec2)).reshape(3)
	    v = np.cross(a, b)
	    c = np.dot(a, b)
	    s = np.linalg.norm(v)
	    kmat = np.array([[0, -v[2], v[1]], [v[2], 0, -v[0]], [-v[1], v[0], 0]])
	    rotation_matrix = np.eye(3) + kmat + kmat.dot(kmat) * ((1 - c) / (s ** 2))
	    return rotation_matrix

	# return a number denoting the js configuration
	def calc_config_number(self, js):
		# declare joint config counter
		config = 1
		th_plus, th_minus = self.th1_solution(js)
		# check first joint configuration
		if abs(js[0] - th_plus) < 0.001:
			# check third joint
			if js[2] >= 0:
				# check fifth joint
				if js[4] < 0:
					config += 1 
			else:
				config += 2
				# check fifth joint
				if js[4] < 0:
					config += 1

		else:
			config+=4
			# check third joint
			if js[2] >= 0:
				# check fifth joint
				if js[4] < 0:
					config += 1 
			else:
				config += 2
				# check fifth joint
				if js[4] < 0:
					config += 1

		return config

	# solution for th1 taken from: http://rasmusan.blog.aau.dk/files/ur5_kinematics.pdf
	# needed to calculate robot joint configuration
	def th1_solution(self, th_n):
		d1 = 0.089159
		a2 = -0.425
		a3 = -0.39225
		d4 = 0.10915
		d5 = 0.09465
		d6 = 0.0823

		s = [math.sin(th) for th in th_n]
		[s1, s2, s3, s4, s5, s6] = s
		c = [math.cos(th) for th in th_n]
		[c1, c2, c3, c4, c5, c6] = c

		x = 1.0*d5*(c4*(1.0*c1*c2*s3 + 1.0*c1*c3*s2) - 1.0*s4*(1.0*c1*s2*s3 - c1*c2*c3)) + d6*(1.0*c5*s1 + 1.0*s5*(s4*(1.0*c1*c2*s3 + 1.0*c1*c3*s2) + c4*(1.0*c1*s2*s3 - c1*c2*c3))) - 1.0*a3*(1.0*c1*s2*s3 - c1*c2*c3) - d6*(1.0*c5*s1 + 1.0*s5*(s4*(1.0*c1*c2*s3 + 1.0*c1*c3*s2) + c4*(1.0*c1*s2*s3 - c1*c2*c3))) + 1.0*d4*s1 + 1.0*a2*c1*c2
 
		y =  1.0*d5*(c4*(1.0*c2*s1*s3 + 1.0*c3*s1*s2) - 1.0*s4*(1.0*s1*s2*s3 - c2*c3*s1)) - d6*(1.0*c1*c5 - 1.0*s5*(s4*(1.0*c2*s1*s3 + 1.0*c3*s1*s2) + c4*(1.0*s1*s2*s3 - c2*c3*s1))) - 1.0*a3*(1.0*s1*s2*s3 - c2*c3*s1) - 1.0*d4*c1 + d6*(1.0*c1*c5 - 1.0*s5*(s4*(1.0*c2*s1*s3 + 1.0*c3*s1*s2) + c4*(1.0*s1*s2*s3 - c2*c3*s1))) + 1.0*a2*c2*s1
 
		th_plus = math.atan2(y,x) + math.acos(d4/math.sqrt(math.pow(x,2)+math.pow(y,2))) + math.pi/2
		th_minus = math.atan2(y,x) - math.acos(d4/math.sqrt(math.pow(x,2)+math.pow(y,2))) + math.pi/2

		# bring to within -pi, pi
		if th_plus > math.pi:
			th_plus = th_plus - math.pi*2

		if th_minus < -math.pi:
			th_minus = math.pi*2 - th_minus

		return th_plus, th_minus

	def config_method(self, js_solutions, configs):
		# define the potential starting configurations
		starting_configs = [i for i in range(1,9)]

		# iterate through each configurations, and build a list of js positions on the path
		# that correspond to each configuration
		results = []
		traj_list = []
		for config_number in starting_configs:
			trajectory = []
			skip = 0
			for j in range(0, len(configs)):
				next_configs = configs[j]
				try:
					index = next_configs.index(config_number)
					trajectory.append(js_solutions[j][index])
				except ValueError:
					skip += 1
					trajectory.append(None)
					continue
			results.append([config_number, trajectory, skip])
			traj_list.append(trajectory)

		# find positions across different configuration paths that are sufficiently 
		# close in joint state to enable a switch. If a switch is possible, keep the longest
		# path to that point found. 
		for i in range(len(traj_list[0])):
			# iterate through each solution that is not none
			for j in range(len(traj_list)):
				config_1 = traj_list[j][i]
				if config_1:
					# iterate through each solution after that is not none
					for k in range(j+1, len(traj_list)):
						config_2 = traj_list[k][i]
						if config_2:
							error = 0
							# check for reaching the [0. 3.14] solution boundary
							for js in range(len(config_1)):
								error += abs(math.atan2(math.sin(config_1[js]-config_2[js]), math.cos(config_1[js]-config_2[js])))
							error = error/6
							# if error sufficiently small, we can switch the trajectories
							if error < 0.5:
								# select longer first half
								len_1 = len([js for js in traj_list[j][0:i] if js])
								len_2 = len([js for js in traj_list[k][0:i] if js])
								if len_1 > len_2:
									new_traj = traj_list[j][0:i]
								else:
									new_traj = traj_list[k][0:i]

								traj_list[j][0:i] = new_traj
								traj_list[k][0:i] = new_traj

		# add resulting trajectories to a dataframe
		# skips refers to the number of points in the path the could not be met with a smooth joint
		# state path				
		improved_results = []
		for traj in traj_list:
			skips = len(traj) - len([x for x in traj if x])
			improved_results.append([traj, skips])
		improved_results_df = pd.DataFrame(data=improved_results, columns=['trajectory', 'skips'])
		
		# select the optimal trajectory to be the one that fulfils the most points
		improved_results_df = improved_results_df.sort_values(by=['skips'])
		improved_results_df = improved_results_df.reset_index()
		self.js_trajectory = improved_results_df['trajectory'].iloc[0]
		# remove all points that are None
		self.js_trajectory = [js for js in self.js_trajectory if js]

		# calculate the configurations in the trajectory for comparison
		self.js_config = [self.calc_config_number(self.js_trajectory[0])]
		for js in self.js_trajectory:
			config = self.calc_config_number(js)
			self.js_config.append(config)

		# ensure smooth transition when the joint limit is reached
		for i in range(len(self.js_trajectory)-1):
			config_1 = list(self.js_trajectory[i])
			config_2 = list(self.js_trajectory[i+1])
			for js in range(len(config_1)):
				error = abs(math.atan2(math.sin(config_2[js]-config_1[js]), math.cos(config_2[js]-config_1[js])))
				diff = abs(config_2[js]-config_1[js])
				if abs(error - diff) > 0.0001:
					config_2[js] = math.atan2(math.sin(config_2[js]-config_1[js]), math.cos(config_2[js]-config_1[js])) + config_1[js]
					self.js_trajectory[i+1] = tuple(config_2)
					